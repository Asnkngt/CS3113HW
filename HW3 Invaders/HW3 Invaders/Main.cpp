#include "Headers.h"
#include "ShaderProgram.h"
//my texture and text handler
#include "TextureManager.h"
#include "Entities.h"

/*
spritesheets used:
Text sprite sheet generated by my in progress ttf text manager
8x8 Space ships (?) + bullets + explosion animation
*/
SDL_Window* displayWindow;

//player dies instantly
//enemy takes 3 hits to die
std::vector<Entities> entities;
std::vector<Entities> text;
int enemycount;

bool running;

/*
Set his to true to prevent death while testing
*/
bool noDeath = false;
float lastFrameTick;

glm::vec2 space;//x and y of play grid
glm::mat4 projectionMatrix;
glm::mat4 viewMatrix;
glm::mat4 mat;

ShaderProgram shaderDefault;
ShaderProgram shaderText;
TTFText textLoader;

GLuint mainTexture;

const Uint8 *keys;

const char* WindowName = "Game";
//used for fixed updates
float accumulator = 0.0f;
//if the game is running slowly, increase the step time wo slow down game
float stepTime = 1.0f / 16.0f;//1.0f / 4.0f;
float stepMove = stepTime * 2.0f;//1.0f / 2.0f;
float startTick;

//distance of grid to left, right and top, bottom
glm::vec2 bounds(7.0f, 13.0f);
int spacing = 1;//space for invaders to move around in
 
int firetick = 8;//number of updates before shooting
int randomrange = 1024;//a rain of bullets but bearable amount

enum State {
    TITLE,
    GAME,
    LOSE,
    WIN
} state;

void init() {
    SDL_Init(SDL_INIT_VIDEO);
    
    displayWindow = SDL_CreateWindow(WindowName, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 480, 640, SDL_WINDOW_OPENGL);
    SDL_GLContext context = SDL_GL_CreateContext(displayWindow);
    SDL_GL_MakeCurrent(displayWindow, context);

#ifdef _WINDOWS
    glewInit();
#endif
    shaderDefault.Load(RESOURCE_FOLDER"vertex_textured.glsl", RESOURCE_FOLDER"fragment_textured.glsl");
    shaderText.Load(RESOURCE_FOLDER"vertex_text.glsl", RESOURCE_FOLDER"fragment_text.glsl");

    keys = SDL_GetKeyboardState(NULL);
}

void initTitle() {
    state = State::TITLE;
    mat = glm::mat4(1.0f);
    projectionMatrix = glm::ortho(-1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
    viewMatrix = glm::mat4(1.0f);
    //clear out entities and text manually
    while (entities.size() > 0) {
        entities.erase(entities.end() - 1);
    }
    while (text.size() > 0) {
        text.erase(text.end() - 1);
    }
    
    //white text saying play
    text.push_back(Entities(&shaderText, &projectionMatrix, &viewMatrix));
    //text[0] = text[1] = text[2] = Entities(&shaderText, &projectionMatrix, &viewMatrix);
    text[0].color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
    text[0].position.y = 0.4f;
    textLoader.calculateBoundedText(text[0], "Hit Enter To Play", 0.25f, -0.8f, 0.8f);

    text.push_back(Entities(&shaderText, &projectionMatrix, &viewMatrix));
    text[1].color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
    text[1].position.y = -0.0f;
    textLoader.calculateBoundedText(text[1], "Controls are left, right", 0.25f, -0.8f, 0.8f);

    text.push_back(Entities(&shaderText, &projectionMatrix, &viewMatrix));
    text[2].color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
    text[2].position.y = -0.4f;
    textLoader.calculateBoundedText(text[2], "and space to fire", 0.25f, -0.8f, 0.8f);

}

void initGame() {
    state = State::GAME;
    mat = glm::mat4(1.0f);
    projectionMatrix = glm::ortho(-bounds.x-0.5f, bounds.x + 0.5f, -bounds.y - 0.5f, bounds.y + 0.5f, -1.0f, 1.0f);
    viewMatrix = glm::mat4(1.0f);

    while (entities.size() > 0) {
        entities.erase(entities.end() - 1);
    }
    while (text.size() > 0) {
        text.erase(text.end() - 1);
    }

    //entity 0 will be player
    entities.push_back(Entities(&shaderDefault, &projectionMatrix, &viewMatrix));
    entities[0].SetType(EntityType::PLAYER);
    entities[0].position.y = -bounds.y;
    //set color of player ship to red
    entities[0].color = glm::vec4(1.0f, 0.0f, 0.0f, 1.0f);
    entities[0].calculateUVs(4, 4, 0);
    
    int curr = 1;
    entities.reserve((size_t)(1 + 3 * (bounds.x - spacing - spacing + 1)));
    enemycount = (int)(3 * (bounds.x - spacing - spacing + 1));
    for (int i = 0; i < 3; ++i) {
        for (int j = spacing; j <= bounds.x - spacing; ++j) {
            entities.push_back(Entities(&shaderDefault, &projectionMatrix, &viewMatrix, glm::vec3(j * 2.0f - bounds.x, bounds.y - i * 1.5f - 1.0f, 0.0f)));
            //entities[curr] = Entities(&shaderDefault, &projectionMatrix, &viewMatrix, glm::vec3(j * 2.0f - bounds.x, bounds.y - i * 1.5f - 1.0f, 0.0f));
            entities[curr].SetType(EntityType::ENEMY_FLY);
            entities[curr].color = glm::vec4(0.0f, 1.0f, 0.2f, 1.0f);
            entities[curr].calculateUVs(4, 4, 1 + (i * 3) + (j % 3));
            //std::cout << 1 + (i * 3) + (j % 3) << std::endl;
            ++curr;
        }
    }

    text.push_back(Entities(&shaderText, &projectionMatrix, &viewMatrix));
    text[0].color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
    text[0].position.y = bounds.y;
    textLoader.calculateBoundedText(text[0], "0:00", 0.25f, -1.0f, 1.0f);

    startTick = (float)SDL_GetTicks() / 1000.0f;
    accumulator = 0.0f;
}

void initLose() {
    state = State::LOSE;
    mat = glm::mat4(1.0f);
    projectionMatrix = glm::ortho(-1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
    viewMatrix = glm::mat4(1.0f);

    while (entities.size() > 0) {
        entities.erase(entities.end() - 1);
    }
    while (text.size() > 0) {
        text.erase(text.end() - 1);
    }

    //white text saying you lost
    text.push_back(Entities(&shaderText, &projectionMatrix, &viewMatrix));
    text[0].color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
    text[0].position.y = -0.4f;
    //due to no spacing for 'I', it looks like it says DED
    textLoader.calculateBoundedText(text[0], "YOU DIED", 1.0f, -0.8f, 0.8f);

    startTick = (float)SDL_GetTicks() / 1000.0f;
    accumulator = 0.0f;
}

void DrawGame();

//even though it says high score, its actually based on time (the number of frames) so the lower the score the better
//I got my score after several attempts ~61 seconds
void initWin() {
    state = State::WIN;
    mat = glm::mat4(1.0f);
    projectionMatrix = glm::ortho(-1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
    viewMatrix = glm::mat4(1.0f);

    while (entities.size() > 0) {
        entities.erase(entities.end() - 1);
    }
    while (text.size() > 0) {
        text.erase(text.end() - 1);
    }

    //best time is measured in frames
    std::ifstream bestTime;
    bestTime.open(RESOURCE_FOLDER"BestTime.txt", std::ifstream::in);
    bool exists = bestTime.is_open();
    int bestScore = -1;
    std::string username;
    if (exists) {
        bestTime >> bestScore >> username;
    }
    bestTime.close();

    text.push_back(Entities(&shaderText, &projectionMatrix, &viewMatrix));
    text[0].color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
    text[0].position.y = 0.4f;
    text.push_back(Entities(&shaderText, &projectionMatrix, &viewMatrix));
    text[1].color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
    text[1].position.y = -0.4f;

    if (!exists || bestScore > (int)accumulator / stepTime) {
        textLoader.calculateBoundedText(text[0], "Congrats on scoring " + std::to_string((int)(accumulator / stepTime)), 0.3f, -0.8f, 0.8f);
        textLoader.calculateBoundedText(text[1], "Put in username in console", 0.3f, -0.8f, 0.8f);
        DrawGame();
        std::ofstream newBestTime;
        std::cout << "Enter username: ";
        std::cin >> username;
        std::cout << std::endl;
        newBestTime.open(RESOURCE_FOLDER"BestTime.txt", std::ofstream::out);
        newBestTime.clear();
        newBestTime << (int)(accumulator / stepTime) << username;
        newBestTime.close();
    }
    else {
        textLoader.calculateBoundedText(text[0], "Current Best: " + username + " " + std::to_string(bestScore), 0.3f, -0.8f, 0.8f);
        textLoader.calculateBoundedText(text[1], "Your Time " + std::to_string((int)(accumulator / stepTime)), 0.3f, -0.8f, 0.8f);
    }
    startTick = (float)SDL_GetTicks() / 1000.0f;
    accumulator = 0.0f;
}

void DrawGame() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glUseProgram(shaderDefault.programID);
    glBindTexture(GL_TEXTURE_2D, mainTexture);
    for (Entities& e : entities) {
        e.Draw();
    }
    glUseProgram(shaderText.programID);
    glBindTexture(GL_TEXTURE_2D, textLoader.textID);
    for (Entities& t : text) {
        t.Draw();
    }
    SDL_GL_SwapWindow(displayWindow);
}

//extreamely long update code for each type of entity
void Update() {
    //since enemies move together, might as well calculate it here
    //positions possible = 2 * spacing / stepMove + 1 for p=0
    //calculated as a function of accumulator
    float enemyShift = (float)((int)(accumulator / stepTime) % (int)(4 * spacing / stepMove + 1));//now it maps to all possible positions going foward
    enemyShift *= stepMove;//convert it to actual motion
    enemyShift -= 2 * spacing;//shift it so there equal chance of negative shift
    enemyShift *= ((int)(accumulator / stepTime / (int)(4 * spacing / stepMove + 1)) % 2) ? 1 : -1;//now it maps to foward and backwars movement
    //std::cout << enemycount << std::endl;
    for (size_t i = 0; i < entities.size(); ++i) {
        int rand = std::rand();
        switch (entities[i].entityType)
        {
        case VOID:
            entities.erase(entities.begin() + i);
            --i;
            break;
        case PLAYER:
            if (keys[SDL_SCANCODE_RIGHT]) {
                entities[i].position.x += stepMove;
                entities[i].position.x = (entities[i].position.x > bounds.x) ? bounds.x : entities[i].position.x;
            }
            if (keys[SDL_SCANCODE_LEFT]) {
                entities[i].position.x -= stepMove;
                entities[i].position.x = (entities[i].position.x < -bounds.x) ? -bounds.x : entities[i].position.x;
            }
            if (((int*)entities[i].data)[0] < firetick) { ++((int*)entities[i].data)[0]; }
            //std::cout << *((int*)e.data) << std::endl;
            if (keys[SDL_SCANCODE_SPACE]) {
                if (((int*)entities[i].data)[0] == firetick) {
                    ((int*)entities[i].data)[0] = 0;
                    size_t index = entities.size();
                    entities.push_back(Entities(&shaderDefault, &projectionMatrix, &viewMatrix, glm::vec3(entities[i].position.x, entities[i].position.y + 1.0f, 0.0f), glm::vec3(0.125, 1.0f, 1.0f)));
                    entities[index].color = glm::vec4(1.0f, 0.0f, 0.0f, 1.0f);
                    entities[index].calculateUVs(4, 4, 10);
                    entities[index].SetType(EntityType::BULLET_P);
                }
            }
            break;
        case BULLET_P:
            entities[i].position.y += 2 * stepMove;
            if (entities[i].position.y > bounds.y + 1.0f) {
                //copy another entity over and delete the current one
                entities[i].SetType(EntityType::VOID);
            }
            break;
        case ENEMY_FLY:
            entities[i].position.x = ((glm::vec3*)entities[i].data)->x + enemyShift;
            if (rand%(randomrange / 2)==0) {
                entities[i].SetType(EntityType::ENEMY_DROP);
            }
            if (rand%randomrange <= ((int*)((char*)entities[i].data + sizeof(glm::vec3)))[0]) {
                ((int*)((char*)entities[i].data + sizeof(glm::vec3)))[0] = 1;
                size_t index = entities.size();
                entities.push_back(Entities(&shaderDefault, &projectionMatrix, &viewMatrix, glm::vec3(entities[i].position.x, entities[i].position.y - 1.0f, 0.0f), glm::vec3(0.125, 1.0f, 1.0f)));
                entities[index].color = glm::vec4(0.0f, 1.0f, 0.0f, 1.0f);
                entities[index].calculateUVs(4, 4, 11);
                entities[index].SetType(EntityType::BULLET_E);
            }
            else
            {
                ((int*)((char*)entities[i].data + sizeof(glm::vec3)))[0] += rand % 2;
            }
            break;
        case ENEMY_DROP:
            entities[i].position.y -= stepMove;
            if (((int*)((char*)entities[i].data + sizeof(glm::vec3)))[2] == 0) {
                ((int*)((char*)entities[i].data + sizeof(glm::vec3)))[2] = (rand % 17) - 8;//now its between -8, 8
            }
            else if (((int*)((char*)entities[i].data + sizeof(glm::vec3)))[2] < 0) {
                ++((int*)((char*)entities[i].data + sizeof(glm::vec3)))[2];
                entities[i].position.x -= stepMove;
                entities[i].position.x = (entities[i].position.x < -bounds.x) ? -bounds.x : entities[i].position.x;
            }
            else {
                --((int*)((char*)entities[i].data + sizeof(glm::vec3)))[2];
                entities[i].position.x += stepMove;
                entities[i].position.x = (entities[i].position.x > bounds.x) ? bounds.x : entities[i].position.x;
            }
            if (rand%randomrange <= ((int*)((char*)entities[i].data + sizeof(glm::vec3)))[0]) {
                ((int*)((char*)entities[i].data + sizeof(glm::vec3)))[0] = 1;
                size_t index = entities.size();
                entities.push_back(Entities(&shaderDefault, &projectionMatrix, &viewMatrix, glm::vec3(entities[i].position.x, entities[i].position.y - 1.0f, 0.0f), glm::vec3(0.125, 1.0f, 1.0f)));
                entities[index].color = glm::vec4(0.0f, 1.0f, 0.0f, 1.0f);
                entities[index].calculateUVs(4, 4, 11);
                entities[index].SetType(EntityType::BULLET_E);
            }
            else
            {
                ((int*)((char*)entities[i].data + sizeof(glm::vec3)))[0] += rand % 2;
            }
            if (entities[i].position.y < -bounds.y - 1.0f) {
                entities[i].SetType(EntityType::ENEMY_FLY);
                entities[i].position.x = ((glm::vec3*)entities[i].data)->x + enemyShift;
            }
            break;
        case BULLET_E:
            entities[i].position.y -= 2 * stepMove;
            if (entities[i].position.y < -bounds.y - 1.0f) {
                //copy another entity over and delete the current one
                entities[i].SetType(EntityType::VOID);//fake "delete"
                entities[i] = entities[entities.size() - 1];
                entities[entities.size() - 1].SetType(EntityType::VOID);
                entities.pop_back();
            }
            break;
        case EXPLOSITON:
            entities[i].color = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
            entities[i].calculateUVs(4, 4, ++((int*)entities[i].data)[0] / 4 + 12);
            if (((int*)entities[i].data)[0] >= 15) {
                entities[i].SetType(EntityType::VOID);
            }
            break;
        default:
            break;
        }
    }

    //collision checking
    for (size_t i = 0; i < entities.size(); ++i) {
        size_t j;
        bool exitLoop = false;
        switch (entities[i].entityType)
        {
        case PLAYER://checks player with enemy dropped or enemy bullet which means they died
            for (j = 0; !noDeath && !exitLoop && j < entities.size(); ++j) {
                switch (entities[j].entityType)
                {
                case EntityType::BULLET_E:
                    if (BoxBoxC(entities[i], entities[j])) {
                        initLose();
                        return;
                    }
                    continue;
                case EntityType::ENEMY_DROP:
                    if (BoxBoxC(entities[i], entities[j])) {
                        initLose();
                        return;
                    }
                    continue;
                default:
                    continue;
                }
            }
            continue;
        case BULLET_P://checks bullet with enemy dropped, enemy flying or enemy bullet
            for (j = 0; !exitLoop && j < entities.size(); ++j) {
                //std::cout << i << ' ' << j << std::endl;
                switch (entities[j].entityType)
                {
                case EntityType::BULLET_E://destory both
                    if (BoxBoxC(entities[i], entities[j])) {
                        entities[i].SetType(EntityType::VOID);
                        entities[j].SetType(EntityType::VOID);
                        exitLoop = true;
                    }
                    continue;
                case EntityType::ENEMY_DROP:
                    if (BoxBoxC(entities[i], entities[j])) {
                        entities[i].SetType(EntityType::VOID);
                        --((int*)((char*)entities[j].data + sizeof(glm::vec3)))[1];
                        if (((int*)((char*)entities[j].data + sizeof(glm::vec3)))[1] <= 0) {
                            //entities[j].SetType(EntityType::VOID);
                            entities[j].SetType(EntityType::EXPLOSITON);
                            --enemycount;
                        }
                        exitLoop = true;
                    }
                    continue;
                case EntityType::ENEMY_FLY:
                    if (BoxBoxC(entities[i], entities[j])) {
                        entities[i].SetType(EntityType::VOID);
                        --((int*)((char*)entities[j].data + sizeof(glm::vec3)))[1];
                        if (((int*)((char*)entities[j].data + sizeof(glm::vec3)))[1] <= 0) {
                            //entities[j].SetType(EntityType::VOID);
                            entities[j].SetType(EntityType::EXPLOSITON);
                            --enemycount;
                        }
                        exitLoop = true;
                    }
                    continue;

                }
            }
            continue;
        }
    }
    if (enemycount == 0) {
        initWin();
    }
}

void GameLogic(const float& elapsed, const float& currentTick) {
    float gameTick = currentTick - startTick;
    int sec = (int)gameTick;
    switch (state)
    {
    case TITLE:
        break;
    case GAME:
        textLoader.calculateBoundedText(text[0], std::to_string(sec / 60) + ":" + ((sec % 60 < 10) ? "0" : "") + std::to_string(sec % 60), 0.5f, -1.0f, 1.0f);
        while (state == GAME && accumulator + stepTime <= gameTick) {
            accumulator += stepTime;
            Update();
        }
        break;
    case LOSE:
        while (accumulator + stepTime <= gameTick) {
            accumulator += stepTime;
            text[0].color = glm::vec4(1.0f - accumulator / 4.0f, 1.0f - accumulator / 4.0f, 1.0f - accumulator / 4.0f, 1.0f);

        }
        if (accumulator >= 4.0f) {
            initTitle();
        }
        break;
    case WIN:
        while (accumulator + stepTime <= gameTick) {
            accumulator += stepTime;
            text[1].color = text[0].color = glm::vec4(1.0f - accumulator / 4.0f, 1.0f - accumulator / 4.0f, 1.0f - accumulator / 4.0f, 1.0f);
        }
        if (accumulator >= 4.0f) {
            initTitle();
        }
        break;
    }
}

int main(int argc, char *argv[])
{
    init();
    textLoader = TTFText(RESOURCE_FOLDER"expressway");
    //to update quality, delete the current bitmap file
    if (!textLoader.LoadFont(4)) {
        return 0;
    }
    mainTexture = LoadTexture(RESOURCE_FOLDER"8x8Textures.png", TextureFormat::RGBA());

    initTitle();

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    lastFrameTick = (float)SDL_GetTicks() / 1000.0f;
    SDL_Event event;
    bool done = false;
    while (!done) {
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT || event.type == SDL_WINDOWEVENT_CLOSE) {
                done = true;
            }
            switch (state) {
            case State::TITLE:
                if (event.type == SDL_KEYUP) {
                    if (event.key.keysym.sym == SDLK_RETURN) {
                        std::cout << "Starting Game" << std::endl;
                        initGame();
                    }
                }
                break;
            case State::GAME:
                break;
            }
        }
        float currentTick = (float)SDL_GetTicks() / 1000.0f;
        float elapsed = currentTick - lastFrameTick;

        DrawGame();
        GameLogic(elapsed, currentTick);
        lastFrameTick = currentTick;
    }
    for (Entities& e : entities) {
        e.SetType(EntityType::VOID);
    }
    for (Entities& e : entities) {
        e.SetType(EntityType::VOID);
    }
    shaderDefault.Cleanup();
    shaderText.Cleanup();
    //clean up memory leaks
    
    SDL_Quit();
    return 0;
}